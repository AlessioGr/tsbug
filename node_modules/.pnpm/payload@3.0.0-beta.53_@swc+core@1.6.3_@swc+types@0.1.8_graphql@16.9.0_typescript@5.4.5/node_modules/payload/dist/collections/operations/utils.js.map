{"version":3,"sources":["../../../src/collections/operations/utils.ts"],"sourcesContent":["import type { forgotPasswordOperation } from '../../auth/operations/forgotPassword.js'\nimport type { loginOperation } from '../../auth/operations/login.js'\nimport type { refreshOperation } from '../../auth/operations/refresh.js'\nimport type { PayloadRequestWithData } from '../../types/index.js'\nimport type { AfterOperationHook, SanitizedCollectionConfig, TypeWithID } from '../config/types.js'\nimport type { countOperation } from './count.js'\nimport type { createOperation } from './create.js'\nimport type { deleteOperation } from './delete.js'\nimport type { deleteByIDOperation } from './deleteByID.js'\nimport type { findOperation } from './find.js'\nimport type { findByIDOperation } from './findByID.js'\nimport type { updateOperation } from './update.js'\nimport type { updateByIDOperation } from './updateByID.js'\n\nexport type AfterOperationMap<T extends TypeWithID> = {\n  count: typeof countOperation\n  create: typeof createOperation // todo: pass correct generic\n  delete: typeof deleteOperation // todo: pass correct generic\n  deleteByID: typeof deleteByIDOperation // todo: pass correct generic\n  find: typeof findOperation<T>\n  findByID: typeof findByIDOperation<T>\n  forgotPassword: typeof forgotPasswordOperation\n  login: typeof loginOperation\n  refresh: typeof refreshOperation\n  update: typeof updateOperation // todo: pass correct generic\n  updateByID: typeof updateByIDOperation // todo: pass correct generic\n}\nexport type AfterOperationArg<T extends TypeWithID> = {\n  /** The collection which this hook is being run on */\n  collection: SanitizedCollectionConfig\n  req: PayloadRequestWithData\n} & (\n  | {\n      args: Parameters<AfterOperationMap<T>['count']>[0]\n      operation: 'count'\n      result: Awaited<ReturnType<AfterOperationMap<T>['count']>>\n    }\n  | {\n      args: Parameters<AfterOperationMap<T>['create']>[0]\n      operation: 'create'\n      result: Awaited<ReturnType<AfterOperationMap<T>['create']>>\n    }\n  | {\n      args: Parameters<AfterOperationMap<T>['delete']>[0]\n      operation: 'delete'\n      result: Awaited<ReturnType<AfterOperationMap<T>['delete']>>\n    }\n  | {\n      args: Parameters<AfterOperationMap<T>['deleteByID']>[0]\n      operation: 'deleteByID'\n      result: Awaited<ReturnType<AfterOperationMap<T>['deleteByID']>>\n    }\n  | {\n      args: Parameters<AfterOperationMap<T>['find']>[0]\n      operation: 'find'\n      result: Awaited<ReturnType<AfterOperationMap<T>['find']>>\n    }\n  | {\n      args: Parameters<AfterOperationMap<T>['findByID']>[0]\n      operation: 'findByID'\n      result: Awaited<ReturnType<AfterOperationMap<T>['findByID']>>\n    }\n  | {\n      args: Parameters<AfterOperationMap<T>['forgotPassword']>[0]\n      operation: 'forgotPassword'\n      result: Awaited<ReturnType<AfterOperationMap<T>['forgotPassword']>>\n    }\n  | {\n      args: Parameters<AfterOperationMap<T>['login']>[0]\n      operation: 'login'\n      result: Awaited<ReturnType<AfterOperationMap<T>['login']>>\n    }\n  | {\n      args: Parameters<AfterOperationMap<T>['refresh']>[0]\n      operation: 'refresh'\n      result: Awaited<ReturnType<AfterOperationMap<T>['refresh']>>\n    }\n  | {\n      args: Parameters<AfterOperationMap<T>['update']>[0]\n      operation: 'update'\n      result: Awaited<ReturnType<AfterOperationMap<T>['update']>>\n    }\n  | {\n      args: Parameters<AfterOperationMap<T>['updateByID']>[0]\n      operation: 'updateByID'\n      result: Awaited<ReturnType<AfterOperationMap<T>['updateByID']>>\n    }\n)\n\n// export type AfterOperationHook = typeof buildAfterOperation;\n\nexport const buildAfterOperation = async <\n  T extends TypeWithID = any,\n  O extends keyof AfterOperationMap<T> = keyof AfterOperationMap<T>,\n>(\n  operationArgs: Omit<AfterOperationArg<T>, 'req'> & { operation: O },\n): Promise<Awaited<ReturnType<AfterOperationMap<T>[O]>>> => {\n  const { args, collection, operation, result } = operationArgs\n\n  let newResult = result\n\n  await args.collection.config.hooks.afterOperation.reduce(\n    async (priorHook, hook: AfterOperationHook<T>) => {\n      await priorHook\n\n      const hookResult = await hook({\n        args,\n        collection,\n        operation,\n        req: args.req,\n        result: newResult,\n      } as AfterOperationArg<T>)\n\n      if (hookResult !== undefined) {\n        newResult = hookResult\n      }\n    },\n    Promise.resolve(),\n  )\n\n  return newResult\n}\n"],"names":["buildAfterOperation","operationArgs","args","collection","operation","result","newResult","config","hooks","afterOperation","reduce","priorHook","hook","hookResult","req","undefined","Promise","resolve"],"rangeMappings":";;;;;;;;;;;;;;;;;;","mappings":"AAyFA,+DAA+D;AAE/D,OAAO,MAAMA,sBAAsB,OAIjCC;IAEA,MAAM,EAAEC,IAAI,EAAEC,UAAU,EAAEC,SAAS,EAAEC,MAAM,EAAE,GAAGJ;IAEhD,IAAIK,YAAYD;IAEhB,MAAMH,KAAKC,UAAU,CAACI,MAAM,CAACC,KAAK,CAACC,cAAc,CAACC,MAAM,CACtD,OAAOC,WAAWC;QAChB,MAAMD;QAEN,MAAME,aAAa,MAAMD,KAAK;YAC5BV;YACAC;YACAC;YACAU,KAAKZ,KAAKY,GAAG;YACbT,QAAQC;QACV;QAEA,IAAIO,eAAeE,WAAW;YAC5BT,YAAYO;QACd;IACF,GACAG,QAAQC,OAAO;IAGjB,OAAOX;AACT,EAAC"}