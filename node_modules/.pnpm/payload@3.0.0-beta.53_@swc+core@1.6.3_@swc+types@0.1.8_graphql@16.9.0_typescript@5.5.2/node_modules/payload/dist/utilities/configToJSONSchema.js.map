{"version":3,"sources":["../../src/utilities/configToJSONSchema.ts"],"sourcesContent":["import type { JSONSchema4, JSONSchema4TypeName } from 'json-schema'\n\nimport pluralize from 'pluralize'\nconst { singular } = pluralize\n\nimport type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { Field, FieldAffectingData, Option } from '../fields/config/types.js'\nimport type { SanitizedGlobalConfig } from '../globals/config/types.js'\n\nimport { MissingEditorProp } from '../errors/MissingEditorProp.js'\nimport { fieldAffectsData, tabHasName } from '../fields/config/types.js'\nimport { deepCopyObject } from './deepCopyObject.js'\nimport { toWords } from './formatLabels.js'\nimport { getCollectionIDFieldTypes } from './getCollectionIDFieldTypes.js'\n\nconst fieldIsRequired = (field: Field) => {\n  const isConditional = Boolean(field?.admin && field?.admin?.condition)\n  if (isConditional) return false\n\n  const isMarkedRequired = 'required' in field && field.required === true\n  if (fieldAffectsData(field) && isMarkedRequired) return true\n\n  // if any subfields are required, this field is required\n  if ('fields' in field && field.type !== 'array') {\n    return field.fields.some((subField) => fieldIsRequired(subField))\n  }\n\n  // if any tab subfields have required fields, this field is required\n  if (field.type === 'tabs') {\n    return field.tabs.some((tab) => {\n      if ('name' in tab) {\n        return tab.fields.some((subField) => fieldIsRequired(subField))\n      }\n      return false\n    })\n  }\n\n  return false\n}\n\nfunction buildOptionEnums(options: Option[]): string[] {\n  return options.map((option) => {\n    if (typeof option === 'object' && 'value' in option) {\n      return option.value\n    }\n\n    return option\n  })\n}\n\nfunction generateEntitySchemas(\n  entities: (SanitizedCollectionConfig | SanitizedGlobalConfig)[],\n): JSONSchema4 {\n  const properties = [...entities].reduce((acc, { slug }) => {\n    acc[slug] = {\n      $ref: `#/definitions/${slug}`,\n    }\n\n    return acc\n  }, {})\n\n  return {\n    type: 'object',\n    additionalProperties: false,\n    properties,\n    required: Object.keys(properties),\n  }\n}\n\nfunction generateLocaleEntitySchemas(localization: SanitizedConfig['localization']): JSONSchema4 {\n  if (localization && 'locales' in localization && localization?.locales) {\n    const localesFromConfig = localization?.locales\n\n    const locales = [...localesFromConfig].map((locale) => {\n      return locale.code\n    }, [])\n\n    return {\n      type: 'string',\n      enum: locales,\n    }\n  }\n\n  return {\n    type: 'null',\n  }\n}\n\nfunction generateAuthEntitySchemas(entities: SanitizedCollectionConfig[]): JSONSchema4 {\n  const properties: JSONSchema4[] = [...entities]\n    .filter(({ auth }) => Boolean(auth))\n    .map(({ slug }) => {\n      return {\n        allOf: [\n          { $ref: `#/definitions/${slug}` },\n          {\n            type: 'object',\n            additionalProperties: false,\n            properties: {\n              collection: { type: 'string', enum: [slug] },\n            },\n            required: ['collection'],\n          },\n        ],\n      }\n    }, {})\n\n  return {\n    oneOf: properties,\n  }\n}\n\n/**\n * Returns a JSON Schema Type with 'null' added if the field is not required.\n */\nexport function withNullableJSONSchemaType(\n  fieldType: JSONSchema4TypeName,\n  isRequired: boolean,\n): JSONSchema4TypeName | JSONSchema4TypeName[] {\n  const fieldTypes = [fieldType]\n  if (isRequired) return fieldType\n  fieldTypes.push('null')\n  return fieldTypes\n}\n\nexport function fieldsToJSONSchema(\n  /**\n   * Used for relationship fields, to determine whether to use a string or number type for the ID.\n   * While there is a default ID field type set by the db adapter, they can differ on a collection-level\n   * if they have custom ID fields.\n   */\n  collectionIDFieldTypes: { [key: string]: 'number' | 'string' },\n  fields: Field[],\n  /**\n   * Allows you to define new top-level interfaces that can be re-used in the output schema.\n   */\n  interfaceNameDefinitions: Map<string, JSONSchema4>,\n  config?: SanitizedConfig,\n): {\n  properties: {\n    [k: string]: JSONSchema4\n  }\n  required: string[]\n} {\n  const requiredFieldNames = new Set<string>()\n\n  return {\n    properties: Object.fromEntries(\n      fields.reduce((fieldSchemas, field) => {\n        const isRequired = fieldAffectsData(field) && fieldIsRequired(field)\n        if (isRequired) requiredFieldNames.add(field.name)\n\n        let fieldSchema: JSONSchema4\n        switch (field.type) {\n          case 'text':\n            if (field.hasMany === true) {\n              fieldSchema = {\n                type: withNullableJSONSchemaType('array', isRequired),\n                items: { type: 'string' },\n              }\n            } else {\n              fieldSchema = { type: withNullableJSONSchemaType('string', isRequired) }\n            }\n            break\n          case 'textarea':\n          case 'code':\n          case 'email':\n          case 'date': {\n            fieldSchema = { type: withNullableJSONSchemaType('string', isRequired) }\n            break\n          }\n\n          case 'number': {\n            if (field.hasMany === true) {\n              fieldSchema = {\n                type: withNullableJSONSchemaType('array', isRequired),\n                items: { type: 'number' },\n              }\n            } else {\n              fieldSchema = { type: withNullableJSONSchemaType('number', isRequired) }\n            }\n            break\n          }\n\n          case 'checkbox': {\n            fieldSchema = { type: withNullableJSONSchemaType('boolean', isRequired) }\n            break\n          }\n\n          case 'json': {\n            fieldSchema = {\n              type: ['object', 'array', 'string', 'number', 'boolean', 'null'],\n            }\n            break\n          }\n\n          case 'richText': {\n            if (!field?.editor) {\n              throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n            }\n            if (typeof field.editor === 'function') {\n              throw new Error('Attempted to access unsanitized rich text editor.')\n            }\n            if (field.editor.outputSchema) {\n              fieldSchema = field.editor.outputSchema({\n                collectionIDFieldTypes,\n                config,\n                field,\n                interfaceNameDefinitions,\n                isRequired,\n              })\n            } else {\n              // Maintain backwards compatibility with existing rich text editors\n              fieldSchema = {\n                type: withNullableJSONSchemaType('array', isRequired),\n                items: {\n                  type: 'object',\n                },\n              }\n            }\n\n            break\n          }\n\n          case 'radio': {\n            fieldSchema = {\n              type: withNullableJSONSchemaType('string', isRequired),\n              enum: buildOptionEnums(field.options),\n            }\n\n            break\n          }\n\n          case 'select': {\n            const optionEnums = buildOptionEnums(field.options)\n\n            if (field.hasMany) {\n              fieldSchema = {\n                type: withNullableJSONSchemaType('array', isRequired),\n                items: {\n                  type: 'string',\n                  enum: optionEnums,\n                },\n              }\n            } else {\n              fieldSchema = {\n                type: withNullableJSONSchemaType('string', isRequired),\n                enum: optionEnums,\n              }\n            }\n\n            break\n          }\n\n          case 'point': {\n            fieldSchema = {\n              type: withNullableJSONSchemaType('array', isRequired),\n              items: [\n                {\n                  type: 'number',\n                },\n                {\n                  type: 'number',\n                },\n              ],\n              maxItems: 2,\n              minItems: 2,\n            }\n            break\n          }\n\n          case 'relationship': {\n            if (Array.isArray(field.relationTo)) {\n              if (field.hasMany) {\n                fieldSchema = {\n                  type: withNullableJSONSchemaType('array', isRequired),\n                  items: {\n                    oneOf: field.relationTo.map((relation) => {\n                      return {\n                        type: 'object',\n                        additionalProperties: false,\n                        properties: {\n                          relationTo: {\n                            const: relation,\n                          },\n                          value: {\n                            oneOf: [\n                              {\n                                type: collectionIDFieldTypes[relation],\n                              },\n                              {\n                                $ref: `#/definitions/${relation}`,\n                              },\n                            ],\n                          },\n                        },\n                        required: ['value', 'relationTo'],\n                      }\n                    }),\n                  },\n                }\n              } else {\n                fieldSchema = {\n                  oneOf: field.relationTo.map((relation) => {\n                    return {\n                      type: withNullableJSONSchemaType('object', isRequired),\n                      additionalProperties: false,\n                      properties: {\n                        relationTo: {\n                          const: relation,\n                        },\n                        value: {\n                          oneOf: [\n                            {\n                              type: collectionIDFieldTypes[relation],\n                            },\n                            {\n                              $ref: `#/definitions/${relation}`,\n                            },\n                          ],\n                        },\n                      },\n                      required: ['value', 'relationTo'],\n                    }\n                  }),\n                }\n              }\n            } else if (field.hasMany) {\n              fieldSchema = {\n                type: withNullableJSONSchemaType('array', isRequired),\n                items: {\n                  oneOf: [\n                    {\n                      type: collectionIDFieldTypes[field.relationTo],\n                    },\n                    {\n                      $ref: `#/definitions/${field.relationTo}`,\n                    },\n                  ],\n                },\n              }\n            } else {\n              fieldSchema = {\n                oneOf: [\n                  {\n                    type: withNullableJSONSchemaType(\n                      collectionIDFieldTypes[field.relationTo],\n                      isRequired,\n                    ),\n                  },\n                  {\n                    $ref: `#/definitions/${field.relationTo}`,\n                  },\n                ],\n              }\n            }\n\n            break\n          }\n\n          case 'upload': {\n            fieldSchema = {\n              oneOf: [\n                {\n                  type: collectionIDFieldTypes[field.relationTo],\n                },\n                {\n                  $ref: `#/definitions/${field.relationTo}`,\n                },\n              ],\n            }\n            if (!isRequired) fieldSchema.oneOf.push({ type: 'null' })\n            break\n          }\n\n          case 'blocks': {\n            fieldSchema = {\n              type: withNullableJSONSchemaType('array', isRequired),\n              items: {\n                oneOf: field.blocks.map((block) => {\n                  const blockFieldSchemas = fieldsToJSONSchema(\n                    collectionIDFieldTypes,\n                    block.fields,\n                    interfaceNameDefinitions,\n                    config,\n                  )\n\n                  const blockSchema: JSONSchema4 = {\n                    type: 'object',\n                    additionalProperties: false,\n                    properties: {\n                      ...blockFieldSchemas.properties,\n                      blockType: {\n                        const: block.slug,\n                      },\n                    },\n                    required: ['blockType', ...blockFieldSchemas.required],\n                  }\n\n                  if (block.interfaceName) {\n                    interfaceNameDefinitions.set(block.interfaceName, blockSchema)\n\n                    return {\n                      $ref: `#/definitions/${block.interfaceName}`,\n                    }\n                  }\n\n                  return blockSchema\n                }),\n              },\n            }\n            break\n          }\n\n          case 'array': {\n            fieldSchema = {\n              type: withNullableJSONSchemaType('array', isRequired),\n              items: {\n                type: 'object',\n                additionalProperties: false,\n                ...fieldsToJSONSchema(\n                  collectionIDFieldTypes,\n                  field.fields,\n                  interfaceNameDefinitions,\n                  config,\n                ),\n              },\n            }\n\n            if (field.interfaceName) {\n              interfaceNameDefinitions.set(field.interfaceName, fieldSchema)\n\n              fieldSchema = {\n                $ref: `#/definitions/${field.interfaceName}`,\n              }\n            }\n            break\n          }\n\n          case 'row':\n          case 'collapsible': {\n            const childSchema = fieldsToJSONSchema(\n              collectionIDFieldTypes,\n              field.fields,\n              interfaceNameDefinitions,\n              config,\n            )\n            Object.entries(childSchema.properties).forEach(([propName, propSchema]) => {\n              fieldSchemas.set(propName, propSchema)\n            })\n            childSchema.required.forEach((propName) => {\n              requiredFieldNames.add(propName)\n            })\n            break\n          }\n\n          case 'tabs': {\n            field.tabs.forEach((tab) => {\n              const childSchema = fieldsToJSONSchema(\n                collectionIDFieldTypes,\n                tab.fields,\n                interfaceNameDefinitions,\n                config,\n              )\n              if (tabHasName(tab)) {\n                // could have interface\n                fieldSchemas.set(tab.name, {\n                  type: 'object',\n                  additionalProperties: false,\n                  ...childSchema,\n                })\n\n                // If the named tab has any required fields then we mark this as required otherwise it should be optional\n                const hasRequiredFields = tab.fields.some((subField) => fieldIsRequired(subField))\n\n                if (hasRequiredFields) {\n                  requiredFieldNames.add(tab.name)\n                }\n              } else {\n                Object.entries(childSchema.properties).forEach(([propName, propSchema]) => {\n                  fieldSchemas.set(propName, propSchema)\n                })\n                childSchema.required.forEach((propName) => {\n                  requiredFieldNames.add(propName)\n                })\n              }\n            })\n            break\n          }\n\n          case 'group': {\n            fieldSchema = {\n              type: 'object',\n              additionalProperties: false,\n              ...fieldsToJSONSchema(\n                collectionIDFieldTypes,\n                field.fields,\n                interfaceNameDefinitions,\n                config,\n              ),\n            }\n\n            if (field.interfaceName) {\n              interfaceNameDefinitions.set(field.interfaceName, fieldSchema)\n\n              fieldSchema = {\n                $ref: `#/definitions/${field.interfaceName}`,\n              }\n            }\n            break\n          }\n\n          default: {\n            break\n          }\n        }\n\n        if (fieldSchema && fieldAffectsData(field)) {\n          fieldSchemas.set(field.name, fieldSchema)\n        }\n\n        return fieldSchemas\n      }, new Map<string, JSONSchema4>()),\n    ),\n    required: Array.from(requiredFieldNames),\n  }\n}\n\n// This function is part of the public API and is exported through payload/utilities\nexport function entityToJSONSchema(\n  config: SanitizedConfig,\n  incomingEntity: SanitizedCollectionConfig | SanitizedGlobalConfig,\n  interfaceNameDefinitions: Map<string, JSONSchema4>,\n  defaultIDType: 'number' | 'text',\n): JSONSchema4 {\n  const entity: SanitizedCollectionConfig | SanitizedGlobalConfig = deepCopyObject(incomingEntity)\n  const title = entity.typescript?.interface\n    ? entity.typescript.interface\n    : singular(toWords(entity.slug, true))\n\n  const idField: FieldAffectingData = { name: 'id', type: defaultIDType as 'text', required: true }\n  const customIdField = entity.fields.find(\n    (field) => fieldAffectsData(field) && field.name === 'id',\n  ) as FieldAffectingData\n\n  if (customIdField && customIdField.type !== 'group' && customIdField.type !== 'tab') {\n    customIdField.required = true\n  } else {\n    entity.fields.unshift(idField)\n  }\n\n  // mark timestamp fields required\n  if ('timestamps' in entity && entity.timestamps !== false) {\n    entity.fields = entity.fields.map((field) => {\n      if (fieldAffectsData(field) && (field.name === 'createdAt' || field.name === 'updatedAt')) {\n        return {\n          ...field,\n          required: true,\n        }\n      }\n      return field\n    })\n  }\n\n  if ('auth' in entity && entity.auth && !entity.auth?.disableLocalStrategy) {\n    entity.fields.push({\n      name: 'password',\n      type: 'text',\n    })\n  }\n\n  //  Used for relationship fields, to determine whether to use a string or number type for the ID.\n  const collectionIDFieldTypes = getCollectionIDFieldTypes({ config, defaultIDType })\n\n  return {\n    type: 'object',\n    additionalProperties: false,\n    title,\n    ...fieldsToJSONSchema(collectionIDFieldTypes, entity.fields, interfaceNameDefinitions, config),\n  }\n}\n\n/**\n * This is used for generating the TypeScript types (payload-types.ts) with the payload generate:types command.\n */\nexport function configToJSONSchema(\n  config: SanitizedConfig,\n  defaultIDType?: 'number' | 'text',\n): JSONSchema4 {\n  // a mutable Map to store custom top-level `interfaceName` types. Fields with an `interfaceName` property will be moved to the top-level definitions here\n  const interfaceNameDefinitions: Map<string, JSONSchema4> = new Map()\n\n  // Collections and Globals have to be moved to the top-level definitions as well. Reason: The top-level type will be the `Config` type - we don't want all collection and global\n  // types to be inlined inside the `Config` type\n  const entityDefinitions: { [k: string]: JSONSchema4 } = [\n    ...config.globals,\n    ...config.collections,\n  ].reduce((acc, entity) => {\n    acc[entity.slug] = entityToJSONSchema(config, entity, interfaceNameDefinitions, defaultIDType)\n    return acc\n  }, {})\n\n  return {\n    additionalProperties: false,\n    definitions: { ...entityDefinitions, ...Object.fromEntries(interfaceNameDefinitions) },\n    // These properties here will be very simple, as all the complexity is in the definitions. These are just the properties for the top-level `Config` type\n    type: 'object',\n    properties: {\n      collections: generateEntitySchemas(config.collections || []),\n      globals: generateEntitySchemas(config.globals || []),\n      locale: generateLocaleEntitySchemas(config.localization),\n      user: generateAuthEntitySchemas(config.collections),\n    },\n    required: ['user', 'locale', 'collections', 'globals'],\n    title: 'Config',\n  }\n}\n"],"names":["pluralize","singular","MissingEditorProp","fieldAffectsData","tabHasName","deepCopyObject","toWords","getCollectionIDFieldTypes","fieldIsRequired","field","isConditional","Boolean","admin","condition","isMarkedRequired","required","type","fields","some","subField","tabs","tab","buildOptionEnums","options","map","option","value","generateEntitySchemas","entities","properties","reduce","acc","slug","$ref","additionalProperties","Object","keys","generateLocaleEntitySchemas","localization","locales","localesFromConfig","locale","code","enum","generateAuthEntitySchemas","filter","auth","allOf","collection","oneOf","withNullableJSONSchemaType","fieldType","isRequired","fieldTypes","push","fieldsToJSONSchema","collectionIDFieldTypes","interfaceNameDefinitions","config","requiredFieldNames","Set","fromEntries","fieldSchemas","add","name","fieldSchema","hasMany","items","editor","Error","outputSchema","optionEnums","maxItems","minItems","Array","isArray","relationTo","relation","const","blocks","block","blockFieldSchemas","blockSchema","blockType","interfaceName","set","childSchema","entries","forEach","propName","propSchema","hasRequiredFields","Map","from","entityToJSONSchema","incomingEntity","defaultIDType","entity","title","typescript","interface","idField","customIdField","find","unshift","timestamps","disableLocalStrategy","configToJSONSchema","entityDefinitions","globals","collections","definitions","user"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}